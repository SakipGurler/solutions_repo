{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Motivation Projectile motion provides a simple yet insightful framework for understanding physics concepts. The range of a projectile depends on its angle of projection, influenced by factors like initial velocity and gravitational acceleration. Understanding these dependencies is crucial for applications in sports, engineering, and astrophysics. 2. Theoretical Foundation Equations of Motion Horizontal Motion: \\(x = v_0 \\cos\\theta \\cdot t\\) Vertical Motion: \\(y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\) Time of Flight: \\(T = \\frac{2 v_0 \\sin\\theta}{g}\\) Range Formula: \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) Key Insights Maximum range at \\(\\theta = 45^\\circ\\) Symmetry around \\(45^\\circ\\) Higher \\(v_0\\) increases range quadratically 3. Analysis of the Range Effect of Initial Velocity ( \\(v_0\\) ) : Increases range quadratically Effect of Gravity ( \\(g\\) ) : Higher \\(g\\) reduces range Effect of Launch Height ( \\(h\\) ) : Changes trajectory significantly 4. Practical Applications Sports : Optimizing angles for maximum distance in soccer, basketball, and javelin throw Engineering : Designing projectile paths for missiles and ballistics Astrophysics : Calculating trajectories of celestial bodies 5. Implementation (Python Simulation) import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 20 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=\"Range vs. Angle\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Angle\") plt.legend() plt.grid(True) plt.show() 6. Limitations & Extensions Current Model Constraints No air resistance Assumes flat, even terrain Neglects wind effects Future Work Incorporate air resistance Model variable terrain effects Add wind acceleration components Conclusion The projectile motion analysis reveals the complex interplay between launch angle, initial velocity, and gravitational effects, providing insights into fundamental principles of kinematics.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motivation","text":"Projectile motion provides a simple yet insightful framework for understanding physics concepts. The range of a projectile depends on its angle of projection, influenced by factors like initial velocity and gravitational acceleration. Understanding these dependencies is crucial for applications in sports, engineering, and astrophysics.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal Motion: \\(x = v_0 \\cos\\theta \\cdot t\\) Vertical Motion: \\(y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\) Time of Flight: \\(T = \\frac{2 v_0 \\sin\\theta}{g}\\) Range Formula: \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\)","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-insights","text":"Maximum range at \\(\\theta = 45^\\circ\\) Symmetry around \\(45^\\circ\\) Higher \\(v_0\\) increases range quadratically","title":"Key Insights"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"Effect of Initial Velocity ( \\(v_0\\) ) : Increases range quadratically Effect of Gravity ( \\(g\\) ) : Higher \\(g\\) reduces range Effect of Launch Height ( \\(h\\) ) : Changes trajectory significantly","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-practical-applications","text":"Sports : Optimizing angles for maximum distance in soccer, basketball, and javelin throw Engineering : Designing projectile paths for missiles and ballistics Astrophysics : Calculating trajectories of celestial bodies","title":"4. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-implementation-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 20 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=\"Range vs. Angle\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Angle\") plt.legend() plt.grid(True) plt.show()","title":"5. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-limitations-extensions","text":"","title":"6. Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#current-model-constraints","text":"No air resistance Assumes flat, even terrain Neglects wind effects","title":"Current Model Constraints"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#future-work","text":"Incorporate air resistance Model variable terrain effects Add wind acceleration components","title":"Future Work"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The projectile motion analysis reveals the complex interplay between launch angle, initial velocity, and gravitational effects, providing insights into fundamental principles of kinematics.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Problem 2: Forced Damped Pendulum Dynamics 1. Theoretical Foundation 1.1 Differential Equation The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A \\cos(\\omega t)\\) Where: - \\(\\theta\\) is the angular displacement - \\(b\\) represents the damping coefficient - \\(g\\) is gravitational acceleration - \\(L\\) is pendulum length - \\(A\\) is driving force amplitude - \\(\\omega\\) is driving force frequency 1.2 Small-Angle Approximation For small angles, we can simplify \\(\\sin(\\theta) \\approx \\theta\\) , resulting in a linearized equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A \\cos(\\omega t)\\) 2. Computational Implementation 2.1 Numerical Solution Strategy We'll use the 4th-order Runge-Kutta method to numerically solve the nonlinear differential equation, allowing exploration beyond small-angle approximations. 2.2 Python Simulation Framework import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def forced_damped_pendulum(state, t, b, g, L, A, omega): theta, omega_dot = state dtheta_dt = omega_dot domega_dt = -b*omega_dot - (g/L)*np.sin(theta) + A*np.cos(omega*t) return [dtheta_dt, domega_dt] # Example simulation parameters b = 0.5 # Damping coefficient g = 9.81 # Gravitational acceleration L = 1.0 # Pendulum length A = 0.5 # Driving amplitude omega = 1.2 # Driving frequency # Time array t = np.linspace(0, 50, 1000) # Initial conditions initial_state = [np.pi/4, 0] # Initial angle and angular velocity # Solve ODE solution = odeint(forced_damped_pendulum, initial_state, t, args=(b, g, L, A, omega)) # Plotting plt.figure(figsize=(12, 6)) plt.plot(t, solution[:, 0], label='Angular Displacement') plt.title('Forced Damped Pendulum Dynamics') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.legend() plt.grid(True) plt.show() 3. Dynamical Behavior Analysis 3.1 Resonance Conditions Resonance occurs when driving frequency matches system's natural frequency Energy transfer maximized during precise frequency matching 3.2 Chaos and Transition Regions We'll systematically explore: - Impact of damping coefficient - Variation in driving amplitude - Changes in driving frequency 4. Visualization Techniques 4.1 Phase Portraits Represent system's state space Reveal qualitative behavior transitions 4.2 Poincar\u00e9 Sections Discrete sampling of continuous dynamics Identify periodic and chaotic regimes 5. Practical Applications 5.1 Engineering Contexts Vibration energy harvesting Structural dynamics Mechanical system design Oscillating circuit behavior 6. Limitations and Future Extensions 6.1 Current Model Constraints Linear damping assumption Small-angle approximation Idealized periodic forcing 6.2 Potential Research Directions Nonlinear damping models Stochastic forcing mechanisms Complex geometric configurations Conclusion The forced damped pendulum exemplifies complex nonlinear dynamical systems, bridging theoretical physics and computational modeling.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-forced-damped-pendulum-dynamics","text":"","title":"Problem 2: Forced Damped Pendulum Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-differential-equation","text":"The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A \\cos(\\omega t)\\) Where: - \\(\\theta\\) is the angular displacement - \\(b\\) represents the damping coefficient - \\(g\\) is gravitational acceleration - \\(L\\) is pendulum length - \\(A\\) is driving force amplitude - \\(\\omega\\) is driving force frequency","title":"1.1 Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small angles, we can simplify \\(\\sin(\\theta) \\approx \\theta\\) , resulting in a linearized equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A \\cos(\\omega t)\\)","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-computational-implementation","text":"","title":"2. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-numerical-solution-strategy","text":"We'll use the 4th-order Runge-Kutta method to numerically solve the nonlinear differential equation, allowing exploration beyond small-angle approximations.","title":"2.1 Numerical Solution Strategy"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-python-simulation-framework","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def forced_damped_pendulum(state, t, b, g, L, A, omega): theta, omega_dot = state dtheta_dt = omega_dot domega_dt = -b*omega_dot - (g/L)*np.sin(theta) + A*np.cos(omega*t) return [dtheta_dt, domega_dt] # Example simulation parameters b = 0.5 # Damping coefficient g = 9.81 # Gravitational acceleration L = 1.0 # Pendulum length A = 0.5 # Driving amplitude omega = 1.2 # Driving frequency # Time array t = np.linspace(0, 50, 1000) # Initial conditions initial_state = [np.pi/4, 0] # Initial angle and angular velocity # Solve ODE solution = odeint(forced_damped_pendulum, initial_state, t, args=(b, g, L, A, omega)) # Plotting plt.figure(figsize=(12, 6)) plt.plot(t, solution[:, 0], label='Angular Displacement') plt.title('Forced Damped Pendulum Dynamics') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.legend() plt.grid(True) plt.show()","title":"2.2 Python Simulation Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-dynamical-behavior-analysis","text":"","title":"3. Dynamical Behavior Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-resonance-conditions","text":"Resonance occurs when driving frequency matches system's natural frequency Energy transfer maximized during precise frequency matching","title":"3.1 Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-chaos-and-transition-regions","text":"We'll systematically explore: - Impact of damping coefficient - Variation in driving amplitude - Changes in driving frequency","title":"3.2 Chaos and Transition Regions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-visualization-techniques","text":"","title":"4. Visualization Techniques"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-phase-portraits","text":"Represent system's state space Reveal qualitative behavior transitions","title":"4.1 Phase Portraits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-poincare-sections","text":"Discrete sampling of continuous dynamics Identify periodic and chaotic regimes","title":"4.2 Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-practical-applications","text":"","title":"5. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-engineering-contexts","text":"Vibration energy harvesting Structural dynamics Mechanical system design Oscillating circuit behavior","title":"5.1 Engineering Contexts"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-limitations-and-future-extensions","text":"","title":"6. Limitations and Future Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#61-current-model-constraints","text":"Linear damping assumption Small-angle approximation Idealized periodic forcing","title":"6.1 Current Model Constraints"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#62-potential-research-directions","text":"Nonlinear damping models Stochastic forcing mechanisms Complex geometric configurations","title":"6.2 Potential Research Directions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum exemplifies complex nonlinear dynamical systems, bridging theoretical physics and computational modeling.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: Kepler's Third Law 1. Derivation of Kepler's Third Law for Circular Orbits Kepler's Third Law establishes the relationship between the orbital period of a celestial body and its orbital radius. Let's derive this relationship for circular orbits. For a body in circular orbit: The centripetal force is provided by the gravitational force: \\( \\(F_c = F_g\\) \\) The centripetal force is: \\( \\(F_c = \\frac{mv^2}{r}\\) \\) where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. The gravitational force between two bodies (from Newton's Law of Universal Gravitation) is: \\( \\(F_g = \\frac{GMm}{r^2}\\) \\) where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body, and \\(m\\) is the mass of the orbiting body. Equating these forces: \\( \\(\\frac{mv^2}{r} = \\frac{GMm}{r^2}\\) \\) Simplifying: \\( \\(v^2 = \\frac{GM}{r}\\) \\) For a circular orbit, the orbital velocity relates to the period \\(T\\) as: \\( \\(v = \\frac{2\\pi r}{T}\\) \\) Substituting this into our equation: \\( \\(\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\) \\) Rearranging: \\( \\(\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\) \\) Further simplification: \\( \\(\\frac{4\\pi^2 r^3}{T^2} = GM\\) \\) Therefore: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] This can be written as: \\[T^2 \\propto r^3\\] This is Kepler's Third Law: The square of the orbital period is proportional to the cube of the orbital radius . For a system with multiple orbiting bodies around the same central mass \\(M\\) , we can express this as: \\[\\frac{T_1^2}{T_2^2} = \\frac{r_1^3}{r_2^3}\\] 2. Implications for Astronomy Kepler's Third Law has profound implications for astronomy: Determining Planetary Masses By measuring the orbital period and distance of a planet's moons, we can determine the planet's mass: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] This technique has been crucial for calculating the masses of planets in our Solar System and beyond. Measuring Astronomical Distances For objects orbiting a known mass, measuring the orbital period allows astronomers to calculate their orbital distance, providing a method for determining distances within stellar systems. Detecting Exoplanets The Transit Timing Variation method of exoplanet detection relies on Kepler's Third Law. Variations in a planet's transit timing can indicate the presence of another planet perturbing its orbit. Understanding Binary Star Systems In binary star systems, Kepler's Third Law helps determine the combined mass of the system based on observations of orbital period and separation. Mapping the Milky Way By observing the orbital periods of stars around the galactic center, astronomers can map the mass distribution of our galaxy, including evidence for dark matter. 3. Real-World Examples The Earth-Moon System Orbital radius of the Moon: approximately 384,400 km Orbital period: 27.3 days (sidereal period) Using Kepler's Third Law formula: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] With Earth's mass ( \\(M_E = 5.97 \\times 10^{24}\\) kg) and \\(G = 6.67 \\times 10^{-11} \\text{ N} \\cdot \\text{m}^2/\\text{kg}^2\\) , we can verify this relationship. The Solar System Planet Average Distance from Sun (AU) Orbital Period (years) T\u00b2 / r\u00b3 Mercury 0.39 0.24 1.00 Venus 0.72 0.62 1.00 Earth 1.00 1.00 1.00 Mars 1.52 1.88 1.00 Jupiter 5.20 11.86 1.00 Saturn 9.54 29.46 1.00 Uranus 19.19 84.01 1.00 Neptune 30.06 164.8 1.00 The consistency of the T\u00b2/r\u00b3 ratio (approximately 1 when expressed in astronomical units and years) demonstrates the validity of Kepler's Third Law across the entire Solar System. Geostationary Satellites A practical application of Kepler's Third Law is in placing geostationary satellites. For a satellite to remain above the same point on Earth, it must orbit with a period of exactly one sidereal day (23.93 hours). Using Kepler's Third Law, we can calculate that these satellites must orbit at an altitude of approximately 35,786 km above Earth's surface. 4. Computational Model for Circular Orbits Below is a Python implementation to simulate circular orbits and verify Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg # Function to calculate orbital period using Kepler's Third Law def orbital_period(r, central_mass): \"\"\"Calculate orbital period using Kepler's Third Law Parameters: r (float): Orbital radius in meters central_mass (float): Mass of the central body in kg Returns: float: Orbital period in seconds \"\"\" return 2 * np.pi * np.sqrt(r**3 / (G * central_mass)) # Function to generate points on a circular orbit def circular_orbit(r, num_points=100): \"\"\"Generate points on a circular orbit Parameters: r (float): Radius of the orbit num_points (int): Number of points to generate Returns: tuple: Arrays of x and y coordinates \"\"\" theta = np.linspace(0, 2*np.pi, num_points) x = r * np.cos(theta) y = r * np.sin(theta) return x, y # Create data for the plot def generate_data(): # Radii in AU (1 AU = 1.496e11 meters) radii_au = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.54, 19.19, 30.06]) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Convert to meters au_to_m = 1.496e11 radii_m = radii_au * au_to_m # Calculate periods using Kepler's Third Law (in seconds) periods = np.array([orbital_period(r, M_sun) for r in radii_m]) # Convert periods to years for comparison seconds_in_year = 365.25 * 24 * 3600 periods_years = periods / seconds_in_year # Calculate T^2/r^3 ratio (should be constant) t_squared = periods_years**2 r_cubed = radii_au**3 ratio = t_squared / r_cubed return radii_au, periods_years, ratio, planets # Plot orbits of planets in the Solar System def plot_solar_system(): fig, ax = plt.subplots(figsize=(10, 10)) ax.set_aspect('equal') # Plot the Sun ax.plot(0, 0, 'yo', markersize=15, label='Sun') # Planet colors colors = ['gray', 'orange', 'blue', 'red', 'brown', 'gold', 'lightblue', 'darkblue'] # Get data radii_au, periods_years, _, planets = generate_data() # Plot orbits for i, (r, planet, color) in enumerate(zip(radii_au, planets, colors)): if r < 6: # Only plot inner planets for clarity x, y = circular_orbit(r) ax.plot(x, y, '-', color=color, alpha=0.5) # Plot the planet theta = 2 * np.pi * np.random.random() # Random position in orbit planet_x = r * np.cos(theta) planet_y = r * np.sin(theta) ax.plot(planet_x, planet_y, 'o', color=color, markersize=5 + (i//4), label=planet) ax.set_xlabel('Distance (AU)') ax.set_ylabel('Distance (AU)') ax.set_title('Orbits of Inner Planets in the Solar System') ax.legend(loc='upper right') ax.grid(True) plt.tight_layout() return fig # Plot verification of Kepler's Third Law def plot_keplers_law_verification(): fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6)) # Get data radii_au, periods_years, ratio, planets = generate_data() # Plot T^2 vs r^3 r_cubed = radii_au**3 t_squared = periods_years**2 ax1.scatter(r_cubed, t_squared, c='blue', s=50) # Add planet labels for i, planet in enumerate(planets): ax1.annotate(planet, (r_cubed[i], t_squared[i]), xytext=(5, 5), textcoords='offset points') # Add line of best fit m, b = np.polyfit(r_cubed, t_squared, 1) x_line = np.linspace(0, max(r_cubed) * 1.1, 100) y_line = m * x_line + b ax1.plot(x_line, y_line, 'r--', label=f'Slope = {m:.4f}') ax1.set_xlabel('Orbital Radius Cubed (AU\u00b3)') ax1.set_ylabel('Orbital Period Squared (years\u00b2)') ax1.set_title('Kepler\\'s Third Law: T\u00b2 vs r\u00b3') ax1.legend() ax1.grid(True) # Plot T\u00b2/r\u00b3 ratio (should be constant) ax2.scatter(radii_au, ratio, c='green', s=50) for i, planet in enumerate(planets): ax2.annotate(planet, (radii_au[i], ratio[i]), xytext=(5, 5), textcoords='offset points') ax2.axhline(y=np.mean(ratio), color='r', linestyle='--', label=f'Mean = {np.mean(ratio):.4f}') ax2.set_xlabel('Orbital Radius (AU)') ax2.set_ylabel('T\u00b2/r\u00b3 Ratio') ax2.set_title('Verification of Kepler\\'s Third Law: T\u00b2/r\u00b3 should be constant') ax2.legend() ax2.grid(True) plt.tight_layout() return fig # Function to create an animation of planetary motion def create_orbit_animation(): # Setup the figure and axis fig, ax = plt.subplots(figsize=(10, 10)) ax.set_aspect('equal') ax.set_xlim(-6, 6) ax.set_ylim(-6, 6) ax.set_xlabel('Distance (AU)') ax.set_ylabel('Distance (AU)') ax.set_title('Planetary Motion Following Kepler\\'s Laws') ax.grid(True) # Plot the Sun ax.plot(0, 0, 'yo', markersize=15, label='Sun') # Get planet data radii_au = np.array([0.39, 0.72, 1.0, 1.52, 5.2]) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter'] colors = ['gray', 'orange', 'blue', 'red', 'brown'] # Plot the orbits for r, color in zip(radii_au, colors): x, y = circular_orbit(r) ax.plot(x, y, '-', color=color, alpha=0.3) # Initialize planet positions planet_points = [] for r, color, planet in zip(radii_au, colors, planets): point, = ax.plot([], [], 'o', color=color, markersize=5, label=planet) planet_points.append(point) ax.legend(loc='upper right') # Calculate orbital periods (normalized) periods_normalized = np.array([ orbital_period(r * 1.496e11, M_sun) for r in radii_au ]) periods_normalized = periods_normalized / min(periods_normalized) # Animation update function def update(frame): for i, (point, r, period) in enumerate(zip(planet_points, radii_au, periods_normalized)): # Calculate position based on time and period angle = (frame / period) % (2 * np.pi) x = r * np.cos(angle) y = r * np.sin(angle) point.set_data(x, y) return planet_points ani = FuncAnimation(fig, update, frames=100, interval=50, blit=True) return ani, fig # Execute the functions to generate the figures orbital_plot = plot_solar_system() verification_plot = plot_keplers_law_verification() animation, animation_fig = create_orbit_animation() # The figures can be displayed or saved in a notebook or script This model simulates the orbits of planets around the Sun and verifies that the ratio of T\u00b2/r\u00b3 is constant, as predicted by Kepler's Third Law. 5. Extension to Elliptical Orbits Kepler's Third Law extends to elliptical orbits with a slight modification. In an elliptical orbit, the relationship becomes: \\[T^2 = \\frac{4\\pi^2}{G(M+m)} a^3\\] Where: - \\(T\\) is the orbital period - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(a\\) is the semi-major axis of the elliptical orbit For most planetary systems, \\(M \\gg m\\) , so the formula simplifies to our earlier form: \\[T^2 \\approx \\frac{4\\pi^2}{GM} a^3\\] Key differences for elliptical orbits: Varying Orbital Speed : In elliptical orbits, the orbital speed is not constant. The body moves faster when closer to the focus (periapsis) and slower when farther away (apoapsis), following Kepler's Second Law of equal areas in equal times. Angular Momentum Conservation : The conservation of angular momentum explains why orbital velocity changes with distance from the focus. Energy Conservation : The total energy (kinetic + potential) remains constant throughout the orbit, even as the individual energy components vary. Conclusion Kepler's Third Law represents one of the most elegant and powerful relationships in physics. Its derivation from Newton's laws of motion and gravitation provides a direct link between observable phenomena (orbital periods and distances) and the fundamental forces governing the universe. This relationship has practical applications ranging from spacecraft mission planning to understanding the structure of distant galaxies. With modern computational tools, we can easily visualize and verify this law, just as we have done in this analysis. The extension of Kepler's Third Law to multi-body systems and general relativity continues to be an active area of research, highlighting the enduring importance of this fundamental relationship in our understanding of celestial mechanics.","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law-for-circular-orbits","text":"Kepler's Third Law establishes the relationship between the orbital period of a celestial body and its orbital radius. Let's derive this relationship for circular orbits. For a body in circular orbit: The centripetal force is provided by the gravitational force: \\( \\(F_c = F_g\\) \\) The centripetal force is: \\( \\(F_c = \\frac{mv^2}{r}\\) \\) where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. The gravitational force between two bodies (from Newton's Law of Universal Gravitation) is: \\( \\(F_g = \\frac{GMm}{r^2}\\) \\) where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body, and \\(m\\) is the mass of the orbiting body. Equating these forces: \\( \\(\\frac{mv^2}{r} = \\frac{GMm}{r^2}\\) \\) Simplifying: \\( \\(v^2 = \\frac{GM}{r}\\) \\) For a circular orbit, the orbital velocity relates to the period \\(T\\) as: \\( \\(v = \\frac{2\\pi r}{T}\\) \\) Substituting this into our equation: \\( \\(\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\) \\) Rearranging: \\( \\(\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\) \\) Further simplification: \\( \\(\\frac{4\\pi^2 r^3}{T^2} = GM\\) \\) Therefore: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] This can be written as: \\[T^2 \\propto r^3\\] This is Kepler's Third Law: The square of the orbital period is proportional to the cube of the orbital radius . For a system with multiple orbiting bodies around the same central mass \\(M\\) , we can express this as: \\[\\frac{T_1^2}{T_2^2} = \\frac{r_1^3}{r_2^3}\\]","title":"1. Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law has profound implications for astronomy:","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-planetary-masses","text":"By measuring the orbital period and distance of a planet's moons, we can determine the planet's mass: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] This technique has been crucial for calculating the masses of planets in our Solar System and beyond.","title":"Determining Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#measuring-astronomical-distances","text":"For objects orbiting a known mass, measuring the orbital period allows astronomers to calculate their orbital distance, providing a method for determining distances within stellar systems.","title":"Measuring Astronomical Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#detecting-exoplanets","text":"The Transit Timing Variation method of exoplanet detection relies on Kepler's Third Law. Variations in a planet's transit timing can indicate the presence of another planet perturbing its orbit.","title":"Detecting Exoplanets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#understanding-binary-star-systems","text":"In binary star systems, Kepler's Third Law helps determine the combined mass of the system based on observations of orbital period and separation.","title":"Understanding Binary Star Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mapping-the-milky-way","text":"By observing the orbital periods of stars around the galactic center, astronomers can map the mass distribution of our galaxy, including evidence for dark matter.","title":"Mapping the Milky Way"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-earth-moon-system","text":"Orbital radius of the Moon: approximately 384,400 km Orbital period: 27.3 days (sidereal period) Using Kepler's Third Law formula: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] With Earth's mass ( \\(M_E = 5.97 \\times 10^{24}\\) kg) and \\(G = 6.67 \\times 10^{-11} \\text{ N} \\cdot \\text{m}^2/\\text{kg}^2\\) , we can verify this relationship.","title":"The Earth-Moon System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-solar-system","text":"Planet Average Distance from Sun (AU) Orbital Period (years) T\u00b2 / r\u00b3 Mercury 0.39 0.24 1.00 Venus 0.72 0.62 1.00 Earth 1.00 1.00 1.00 Mars 1.52 1.88 1.00 Jupiter 5.20 11.86 1.00 Saturn 9.54 29.46 1.00 Uranus 19.19 84.01 1.00 Neptune 30.06 164.8 1.00 The consistency of the T\u00b2/r\u00b3 ratio (approximately 1 when expressed in astronomical units and years) demonstrates the validity of Kepler's Third Law across the entire Solar System.","title":"The Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#geostationary-satellites","text":"A practical application of Kepler's Third Law is in placing geostationary satellites. For a satellite to remain above the same point on Earth, it must orbit with a period of exactly one sidereal day (23.93 hours). Using Kepler's Third Law, we can calculate that these satellites must orbit at an altitude of approximately 35,786 km above Earth's surface.","title":"Geostationary Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model-for-circular-orbits","text":"Below is a Python implementation to simulate circular orbits and verify Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg # Function to calculate orbital period using Kepler's Third Law def orbital_period(r, central_mass): \"\"\"Calculate orbital period using Kepler's Third Law Parameters: r (float): Orbital radius in meters central_mass (float): Mass of the central body in kg Returns: float: Orbital period in seconds \"\"\" return 2 * np.pi * np.sqrt(r**3 / (G * central_mass)) # Function to generate points on a circular orbit def circular_orbit(r, num_points=100): \"\"\"Generate points on a circular orbit Parameters: r (float): Radius of the orbit num_points (int): Number of points to generate Returns: tuple: Arrays of x and y coordinates \"\"\" theta = np.linspace(0, 2*np.pi, num_points) x = r * np.cos(theta) y = r * np.sin(theta) return x, y # Create data for the plot def generate_data(): # Radii in AU (1 AU = 1.496e11 meters) radii_au = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.54, 19.19, 30.06]) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Convert to meters au_to_m = 1.496e11 radii_m = radii_au * au_to_m # Calculate periods using Kepler's Third Law (in seconds) periods = np.array([orbital_period(r, M_sun) for r in radii_m]) # Convert periods to years for comparison seconds_in_year = 365.25 * 24 * 3600 periods_years = periods / seconds_in_year # Calculate T^2/r^3 ratio (should be constant) t_squared = periods_years**2 r_cubed = radii_au**3 ratio = t_squared / r_cubed return radii_au, periods_years, ratio, planets # Plot orbits of planets in the Solar System def plot_solar_system(): fig, ax = plt.subplots(figsize=(10, 10)) ax.set_aspect('equal') # Plot the Sun ax.plot(0, 0, 'yo', markersize=15, label='Sun') # Planet colors colors = ['gray', 'orange', 'blue', 'red', 'brown', 'gold', 'lightblue', 'darkblue'] # Get data radii_au, periods_years, _, planets = generate_data() # Plot orbits for i, (r, planet, color) in enumerate(zip(radii_au, planets, colors)): if r < 6: # Only plot inner planets for clarity x, y = circular_orbit(r) ax.plot(x, y, '-', color=color, alpha=0.5) # Plot the planet theta = 2 * np.pi * np.random.random() # Random position in orbit planet_x = r * np.cos(theta) planet_y = r * np.sin(theta) ax.plot(planet_x, planet_y, 'o', color=color, markersize=5 + (i//4), label=planet) ax.set_xlabel('Distance (AU)') ax.set_ylabel('Distance (AU)') ax.set_title('Orbits of Inner Planets in the Solar System') ax.legend(loc='upper right') ax.grid(True) plt.tight_layout() return fig # Plot verification of Kepler's Third Law def plot_keplers_law_verification(): fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6)) # Get data radii_au, periods_years, ratio, planets = generate_data() # Plot T^2 vs r^3 r_cubed = radii_au**3 t_squared = periods_years**2 ax1.scatter(r_cubed, t_squared, c='blue', s=50) # Add planet labels for i, planet in enumerate(planets): ax1.annotate(planet, (r_cubed[i], t_squared[i]), xytext=(5, 5), textcoords='offset points') # Add line of best fit m, b = np.polyfit(r_cubed, t_squared, 1) x_line = np.linspace(0, max(r_cubed) * 1.1, 100) y_line = m * x_line + b ax1.plot(x_line, y_line, 'r--', label=f'Slope = {m:.4f}') ax1.set_xlabel('Orbital Radius Cubed (AU\u00b3)') ax1.set_ylabel('Orbital Period Squared (years\u00b2)') ax1.set_title('Kepler\\'s Third Law: T\u00b2 vs r\u00b3') ax1.legend() ax1.grid(True) # Plot T\u00b2/r\u00b3 ratio (should be constant) ax2.scatter(radii_au, ratio, c='green', s=50) for i, planet in enumerate(planets): ax2.annotate(planet, (radii_au[i], ratio[i]), xytext=(5, 5), textcoords='offset points') ax2.axhline(y=np.mean(ratio), color='r', linestyle='--', label=f'Mean = {np.mean(ratio):.4f}') ax2.set_xlabel('Orbital Radius (AU)') ax2.set_ylabel('T\u00b2/r\u00b3 Ratio') ax2.set_title('Verification of Kepler\\'s Third Law: T\u00b2/r\u00b3 should be constant') ax2.legend() ax2.grid(True) plt.tight_layout() return fig # Function to create an animation of planetary motion def create_orbit_animation(): # Setup the figure and axis fig, ax = plt.subplots(figsize=(10, 10)) ax.set_aspect('equal') ax.set_xlim(-6, 6) ax.set_ylim(-6, 6) ax.set_xlabel('Distance (AU)') ax.set_ylabel('Distance (AU)') ax.set_title('Planetary Motion Following Kepler\\'s Laws') ax.grid(True) # Plot the Sun ax.plot(0, 0, 'yo', markersize=15, label='Sun') # Get planet data radii_au = np.array([0.39, 0.72, 1.0, 1.52, 5.2]) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter'] colors = ['gray', 'orange', 'blue', 'red', 'brown'] # Plot the orbits for r, color in zip(radii_au, colors): x, y = circular_orbit(r) ax.plot(x, y, '-', color=color, alpha=0.3) # Initialize planet positions planet_points = [] for r, color, planet in zip(radii_au, colors, planets): point, = ax.plot([], [], 'o', color=color, markersize=5, label=planet) planet_points.append(point) ax.legend(loc='upper right') # Calculate orbital periods (normalized) periods_normalized = np.array([ orbital_period(r * 1.496e11, M_sun) for r in radii_au ]) periods_normalized = periods_normalized / min(periods_normalized) # Animation update function def update(frame): for i, (point, r, period) in enumerate(zip(planet_points, radii_au, periods_normalized)): # Calculate position based on time and period angle = (frame / period) % (2 * np.pi) x = r * np.cos(angle) y = r * np.sin(angle) point.set_data(x, y) return planet_points ani = FuncAnimation(fig, update, frames=100, interval=50, blit=True) return ani, fig # Execute the functions to generate the figures orbital_plot = plot_solar_system() verification_plot = plot_keplers_law_verification() animation, animation_fig = create_orbit_animation() # The figures can be displayed or saved in a notebook or script This model simulates the orbits of planets around the Sun and verifies that the ratio of T\u00b2/r\u00b3 is constant, as predicted by Kepler's Third Law.","title":"4. Computational Model for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"Kepler's Third Law extends to elliptical orbits with a slight modification. In an elliptical orbit, the relationship becomes: \\[T^2 = \\frac{4\\pi^2}{G(M+m)} a^3\\] Where: - \\(T\\) is the orbital period - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(a\\) is the semi-major axis of the elliptical orbit For most planetary systems, \\(M \\gg m\\) , so the formula simplifies to our earlier form: \\[T^2 \\approx \\frac{4\\pi^2}{GM} a^3\\] Key differences for elliptical orbits: Varying Orbital Speed : In elliptical orbits, the orbital speed is not constant. The body moves faster when closer to the focus (periapsis) and slower when farther away (apoapsis), following Kepler's Second Law of equal areas in equal times. Angular Momentum Conservation : The conservation of angular momentum explains why orbital velocity changes with distance from the focus. Energy Conservation : The total energy (kinetic + potential) remains constant throughout the orbit, even as the individual energy components vary.","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law represents one of the most elegant and powerful relationships in physics. Its derivation from Newton's laws of motion and gravitation provides a direct link between observable phenomena (orbital periods and distances) and the fundamental forces governing the universe. This relationship has practical applications ranging from spacecraft mission planning to understanding the structure of distant galaxies. With modern computational tools, we can easily visualize and verify this law, just as we have done in this analysis. The extension of Kepler's Third Law to multi-body systems and general relativity continues to be an active area of research, highlighting the enduring importance of this fundamental relationship in our understanding of celestial mechanics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}